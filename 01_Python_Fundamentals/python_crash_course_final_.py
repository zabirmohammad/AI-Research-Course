# -*- coding: utf-8 -*-
"""PYTHON_crash_course_final .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14s9zOYUij5-Tlvx5rrNPKQIrSC8TW7bq

#Class 1: Python for AI - From Fundamentals to Objects

Welcome to the AMIR Lab's course on Machine Learning & Deep Learning!

Instructor: Zabir Mohammad

Date: 25/08/25
###Today's Goals:
- Understand the "Why": See why Python is the dominant language for AI and Machine Learning.

- Set Up Our Lab: Get comfortable with our coding environment (this notebook!).

- Master the Fundamentals: Build a solid foundation with Python's core data types, structures, and control flow. This part is detailed, as it's the bedrock for everything that follows.

- Structure for Success: Learn to write reusable functions and bundle data and logic together into a Python class.

Let's dive in!

##Part 1: The "Why" and The "How"
##Why Python for AI/ML?
You might be wondering why we're starting with Python and not another language.
 The answer lies in its incredible ecosystem and design philosophy:

- Simplicity & Readability: Python's syntax is clean and intuitive. This means you spend less time wrestling with the language and more time thinking about the AI problem you're trying to solve. In research, the speed of experimentation is everything.
-The Powerhouse Libraries: Python's true strength is its collection of specialized libraries. We will become experts in the "Big Three":

    - NumPy: For incredibly fast numerical computations, forming the foundation of all data manipulation.

    - Pandas: For importing, cleaning, and analyzing structured data (think of it as a super-powered spreadsheet in code).

    - PyTorch / TensorFlow / Scikit-learn: High-level frameworks for building, training, and deploying machine learning models.


- Massive Community: If you have a question, chances are someone has already answered it online. This vast community support makes learning and troubleshooting much easier.

For this course, we'll primarily use Google Colab, which is a free, cloud-based version of Jupyter Notebook that requires zero installation and gives you access to powerful hardware (like GPUs) for free.

##PLatform for AI model Implementation and Training
##There are mainly two kind python file extension
- File_name.py
- File_name.ipynb


###File type (.py)

(.py) is a Python script file containing plain Python code. It Execute the Entire script at once. We can create and edit in code editors like VS Code, PyCharm, Notepad++ etc.

###File type(.ipynb)

A Interactive Python Notebook file that mixes code cells and markdown cells. It Supports step-by-step execution and inline visualization. it usually Works in Google Colab or Jupyter Notebook.


### Important Question: Use (*.py) or (*.ipynb)

- (.ipynb) is  ideal for data science, ML, tutorials, or research. in other words Learning, exploration, ML projects.
- (.py) is great for writing clean, production-level or automated code

##Platforms for (.ipynb)

In this lessen you are talking about two popular code editor platform for interactive Python nootbook
- Local-Based (i.e Anaconda, VScode)
- Cloud-Based (i.e Google Colab, Kaggle Kernels)

###Local-Based



###Cloud-Based
"""

!nvidia-smi

"""##Part 2: The Building Blocks of Python

As you program in Python, you will frequently work with various forms of data. Variables are indispensable tools for effectively managing and organizing this data within your programs.

-  What are Variables?

  A variable can be thought of as a named container where you can store different data values. By putting data values into these containers, it becomes significantly easier to work with and manage all the diverse data within your programs. Understanding variables is a core concept in Python that you will use constantly.
- Why Use Variables?

  Consider a scenario where you have a story that frequently mentions a character's name and age. If these values needed to be changed, you would have to manually locate and edit every single instance in the entire story. This manual process would be highly inefficient and prone to errors, especially in longer programs. Variables offer an elegant solution by allowing you to store a value once and then refer to it by its assigned name wherever needed.
Problem without variables:

Problem without variables:
"""

print("There once was a man named Rayhan,")
print("he was 70 years old.")
print("He really liked the name Rayhan,")
print("but didn't like being 70.")

"""Creating and using variables:"""

character_name = "Rayhan" # Storing a string value (name)
character_age = "70"    # Storing a numerical value (age)

print("There once was a man named " + character_name + ",")
print("he was " + character_age + " years old.")
print("He really liked the name " + character_name + ",")
print("but didn't like being " + character_age + ".")

"""###2.1 Variables and Basic Data Types
A variable is like a labeled box where you can store a piece of information.
"""

# In Python, you can create a variable and assign it a value with the '=' operator.
course_name = "Introduction to Python" #String
number_of_students = 25            #Integer
pi_approx = 3.14159                #Float
is_first_class = True              #Boolean

"""Python has several built-in data types. Let's look at the most common ones.
####Integers (int)
Whole numbers, positive or negative.

AI Context: Used for counting things like training iterations (epochs), the number of layers in a neural network, or the number of data points.

"""

# An integer
epochs = 50
print(epochs)

# You can check the type of any variable using the type() function.
print("Type of Epoch ", type(epochs))

"""####Floats (float)
Numbers with a decimal point.

AI Context: The most common numeric type in machine learning! Model weights, biases, learning rates, and loss values are almost always floats.
"""

learning_rate = 0.001
loss_value = 0.1234
print(learning_rate)
print(type(loss_value))

"""####Strings (str)
Sequences of characters, used for text. You can use single ' ' or double " " quotes.

AI Context: Used for feature names, class labels (e.g., 'cat', 'dog'), file paths, or model configuration settings.

"""

# A string
model_type = 'Transformer'

print(model_type)
print(type(model_type))

# You can combine strings using the '+' operator
course_name = "Introduction to Python"
greeting = "Welcome to the " + course_name + " class!"
print(greeting)

"""####Booleans (bool)
Represents one of two values: True or False.

AI Context: Extremely important for controlling program flow. Used as flags in functions, like shuffle=True when loading data, or is_training=True in a model.


"""

# A boolean
has_gpu = False
is_training = True
print(has_gpu)
print(type(is_training))

"""###2.2 Python Operators

There are 5 type of python operator.
- Arithmetic Operators
- Comparison Operators
- Logical Operators
- Bitwise Operators
- Assignment Operators

In this course, we basically cover all type of operator except bitwise operator.

####Arithmetic operators

 Arithmetic operators are used to perform basic mathematical operations like addition, subtraction, multiplication and division.
"""

a = 15
b = 4

# Addition
print("Addition:", a + b)

# Subtraction
print("Subtraction:", a - b)

# Multiplication
print("Multiplication:", a * b)

# Division
print("Division:", a / b)

# Floor Division
print("Floor Division:", a // b)

# Modulus
print("Modulus:", a % b)

# Exponentiation
print("Exponentiation:", a ** b)

"""Other Common Math Functions"""

print(abs(-5))       # Absolute value of -5 is 5
print(pow(3, 2))     # 3 raised to the power of 2 (3 squared) is 9
print(max(4, 6))     # The maximum of 4 and 6 is 6
print(min(4, 6))     # The minimum of 4 and 6 is 4
print(round(3.2))    # Rounds 3.2 down to 3
print(round(3.7))    # Rounds 3.7 up to 4

"""####Comparison of Relational operators

Comparison of Relational operators compares the values. It either returns True or False according to the condition.
"""

a = 15
b = 4

print(a > b)
print(a < b)
print(a == b)
print(a != b)
print(a >= b)
print(a <= b)

""" #### Logical operators

 Logical operators perform Logical AND, Logical OR and Logical NOT operations. It is used to combine conditional statements.

The precedence of Logical Operators in Python is as follows:
- Logical not
- logical and
- logical or
"""

a = True
b = False
print(a and b)
print(a or b)
print(not a)

"""####Assignment operators

Assignment operators are used to assign values to the variables. This operator is used to assign the value of the right side of the expression to the left side operand.
"""

# The basic assignment operator is =
x = 10
print(x)

x += 5  # Equivalent to x = x + 5
print("After x+= 5:", x)

x -= 3  # Equivalent to x = x - 3
print("After x-= 3:", x)

x *= 2  # Equivalent to x = x * 2
print("After x*= 2:", x)

x /= 4  # Equivalent to x = x / 4
print("After x/= 4:", x)

x //= 3 # Equivalent to x = x // 3
print("After x//= 1:", x)

x %= 3  # Equivalent to x = x % 3
print("After x%= 3:", x)


x **= 2 # Equivalent to x = x ** 2
print("After x**= 2:", x)

# Note: These examples use simple numeric values, but assignment operators
# work with various data types and operations depending on the operator
# (e.g., += works for string concatenation).

"""##PART 3: The Power of Collections: Data Structures
Often, we need to work with groups of data. Python's built-in data structures are essential.


Documentation: "https://docs.python.org/3/tutorial/datastructures.html"

###Lists (list)
Lists are structures that store collections of ordered information.
An ordered, mutable (changeable) collection of items. This is your go-to structure for holding a sequence of data.

####Key characteristics of Python lists:
- Ordered:
Elements in a list maintain their insertion order.
- Mutable:
Elements within a list can be modified, added, or removed after the list's creation.
- Heterogeneous:
Lists can store elements of different data types within the same list (e.g., integers, strings, floats, or even other lists).
- Indexed:
Elements can be accessed by their position (index), starting from 0 for the first element. Negative indexing can be used to access elements from the end of the list.
- Dynamic Size:
Lists can grow and shrink in size dynamically as elements are added or removed.

AI Context: A list could represent a single data sample (a "feature vector"), a sentence broken into words, or a batch of training data.

Creating a List

Lists are created by enclosing a comma-separated sequence of elements within square brackets ([]). A single list can contain elements of different data types (e.g., strings, numbers, booleans)
"""

friends = ["Rayhan", "Naim", "Tamin", "Shakib", "Tonmoy"] # A list containing only strings
lucky_numbers = [4, 9, 13, 14, 36, 101] # A list containing only numbers
mixed_list = ["Apple", 10, True] # A list containing mixed data types

print(friends)

"""Accessing List Elements"""

my_friends = ["Rayhan", "Naim", "Tamin", "Shakib", "Tonmoy"]
# Indexing:      0        1       2         3         4

print(my_friends)   # Accesses the first element
print(my_friends[2])   # Accesses the third element
print(my_friends[-1])  # Accesses the last element


print(my_friends[1:])  # Slices: all elements from index 1 to the end
print(my_friends[1:4]) # Slices: elements from index 1 up to (but not including) index 3

"""Modifying List Elements"""

my_friends = ["Rayhan", "Naim", "Tamin", "Shakib", "Tonmoy"]
print("Original list:", my_friends)

my_friends[1] = "Nayeem" # The element at index 1 ('Naim') is replaced with 'Nayeem'
print("Modified list:", my_friends)

"""List Functions (Methods)"""

friends = ["Rayhan", "Naim", "Tamim", "Shakib", "Tonmoy"]
lucky_numbers = [4, 9, 13, 14, 36, 101]

print("Original friends:", friends)
print("Original lucky numbers:", lucky_numbers)

# 1. extend()
friends.extend(lucky_numbers)
print("\nFriends after extend (includes lucky_numbers):", friends)

# Reset friends list for subsequent examples
friends = ["Rayhan", "Naim", "Tamin", "Shakib", "Tonmoy"]

# 2. append()
friends.append("Zakir")
print("Friends after append('Zakir'):", friends)

# 3. insert()
friends.insert(1, "Kalam") # Inserts "kalam" at index 1
print("Friends after insert(1, 'Kalam'):", friends)

# 4. remove()
friends.remove("Zakir")
print("Friends after remove('Zakir'):", friends)

# #5. clear() - Uncomment to see in action
# friends.clear()
# print("Friends after clear():", friends)

#6. pop() - Uncomment to see in action
friends.pop() # Removes the last element ('Tonmoy' in current state)
print("Friends after pop():", friends)

# 7. index()
print("\nIndex of 'kalam':", friends.index("Kalam"))


# 8. sort()
numbers = [4, 9, 13, 14, 36, 101]
numbers.sort()
print("Sorted numbers:", numbers)

friends = ["Rayhan", "Naim", "Tamim", "Shakib", "Tonmoy"]
friends.sort()
print("Sorted friends (alphabetical):", friends)

# 9. reverse()

numbers.reverse()
print("Reversed numbers:", numbers)

# 10. copy()
friends_copy = friends.copy()
print("Copied friends list (new list, same elements):", friends_copy)

# using 'in' and 'not in' for membership testing
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)

print(6 not in my_list)

# using min(), max(), count(), len(), and del with a list
another_list = [10, 20, 30, 10, 40, 50]
print("Minimum value:", min(another_list))
print("Maximum value:", max(another_list))
print("Length of the list:", len(another_list))

# using del to remove an element by index
del another_list[2]  # Removes the element at index 2 (which is 30)
print("List after deleting element at index 2:", another_list)

"""###Tuple

A Python tuple is an ordered collection of items, similar to a list, but with the key distinction of being immutable. This means that once a tuple is created, its elements cannot be changed, added, or removed.
####Key Characteristics of Python Tuples:
- Ordered: Items in a tuple maintain a specific order, and this order is preserved.
- Immutable: Elements within a tuple cannot be modified after creation.
- Indexed: Each item in a tuple has an index, starting from 0 for the first element, allowing access to individual items.
- Heterogeneous: Tuples can contain items of different data types (e.g., integers, strings, lists).
- Defined using Parentheses: Tuples are typically created by enclosing comma-separated values within parentheses ().

AI Context: Useful for data that should not be changed, like the shape of a data tensor (e.g., an image of size 224x224 with 3 color channels) or fixed configuration settings.
"""

# prompt: Write code for tuple

# Declaring a tuple representing the dimensions of an image (height, width, channels)
3636
print("Original Tuple (Image Shape):", image_shape)
print("Type of image_shape:", type(image_shape))

# Accessing elements
print("\nAccessing elements:")
print("Height:", image_shape[0])
print("Width:", image_shape[1])
print("Channels:", image_shape[2])

# --- Immutability Demonstration ---
# The following line would cause an error because tuples are immutable:
# image_shape[0] = 256 # Uncommenting this will raise a TypeError

# Slicing tuples (creates a new tuple, does not modify the original)
print("\nSlicing the tuple:")
dimensions_only = image_shape[:2]
print("Dimensions only:", dimensions_only)

"""###Dictionary

An unordered collection of key-value pairs. They are incredibly useful for storing data with descriptive names.

Key characteristics:
- Key-value pairs:
Each item in a dictionary consists of a unique key that maps to a specific value.
- Mutable:
Dictionaries can be modified after creation, allowing you to add, remove, or change key-value pairs.

- No duplicate keys:
Each key in a dictionary must be unique. If you try to assign a value to an existing key, the old value associated with that key will be overwritten.

- Values can be of any data type:
Dictionary values can be of any data type, including other dictionaries, lists, numbers, or strings.

AI Context: Dictionaries are used everywhere. A classic use case is to define model hyperparameters or to store the results of an experiment.

"""

# Declaring a dictionary called hyperparameters
hyperparameters = {
    "learning_rate": 0.001,
    "num_epochs": 100,
    "batch_size": 32,
    "layers": [64, 128, 64],
    "activation": "relu",
}

print("Original hyperparameters:", hyperparameters)

# Accessing values
print("\nAccessing values:")
print("Learning Rate:", hyperparameters["learning_rate"])
print("Number of Epochs:", hyperparameters["num_epochs"])
print("Layers:", hyperparameters["layers"])

# Modifying values
print("\nModifying values:")
hyperparameters["learning_rate"] = 0.0005
hyperparameters["batch_size"] = 64
hyperparameters["layers"].append(32) # Modifying the list within the dictionary

print("Modified hyperparameters:", hyperparameters)

# Adding new key-pair value
print("\nAdding new key-pair value:")
hyperparameters["optimizer"] = "adam"
hyperparameters["dropout_rate"] = 0.2

print("Hyperparameters after adding new keys:", hyperparameters)

# Remove a key-pair value
print("\nRemoving a key-pair value:")
removed_value = hyperparameters.pop("activation")
print(f"Removed activation: {removed_value}")

# Alternative way to remove (raises KeyError if key not found)
del hyperparameters["dropout_rate"]

print("Hyperparameters after removing keys:", hyperparameters)

# Getting items, keys, and values
print("\nDictionary items:", hyperparameters.items()) #Returns a list containing a tuple for each key value pair
print("Dictionary keys:", hyperparameters.keys()) #Returns a list containing the dictionary's keys
print("Dictionary values:", hyperparameters.values()) #Returns a list of all the values in the dictionary

"""###Sets
A Python set is a built-in data type used to store collections of unique, unordered, and immutable elements.
####Key characteristics of Python sets:
- Uniqueness:
Sets only store distinct elements, automatically eliminating duplicates.
- Unordered:
The elements within a set do not maintain a specific order, meaning they cannot be accessed by index.
- Immutable Elements:
While the set itself is mutable (items can be added or removed), the individual elements within a set must be immutable data types (e.g., numbers, strings, tuples). Lists, dictionaries, or other sets cannot be elements of a set.
- Creation:
Sets can be created using curly braces {} with comma-separated elements, or by using the set() constructor with an iterable (like a list or tuple). To create an empty set, the set() function must be used, as {} creates an empty dictionary.
"""

# Declaring a set of unique AI libraries we might use
ai_libraries = {"TensorFlow", "PyTorch", "Scikit-learn", "TensorFlow", "Keras"} # Duplicates are automatically removed
print("Original Set:", ai_libraries)
print("Type of ai_libraries:", type(ai_libraries))

# Adding elements
print("\nAdding elements:")
ai_libraries.add("NumPy")
ai_libraries.add("Pandas")
print("After adding NumPy and Pandas:", ai_libraries)

# Adding a duplicate element (will be ignored)
ai_libraries.add("PyTorch")
print("After adding PyTorch again (ignored):", ai_libraries)

# Removing elements
print("\nRemoving elements:")
ai_libraries.remove("Keras") # Raises a KeyError if the element is not found
print("After removing Keras:", ai_libraries)


# Checking for membership (very efficient)
print("\nChecking for membership:")
print("Is TensorFlow in the set?", "TensorFlow" in ai_libraries)
print("Is Caffe in the set?", "Caffe" in ai_libraries)

"""##Part 4 : Structuring Code for Reusability and Clarity
As our programs get more complex, we need better ways to organize them.

### Controlling the Flow

Now let's see how we can make decisions and repeat actions in our code.

####Conditional Statements (if, elif, else)

If statements are fundamental control structures that empower your programs to make decisions. They allow different blocks of code to be executed based on whether certain conditions are true or false. This enables programs to respond dynamically to input and data


  - An if statement begins with the if keyword, followed by a condition (an expression that evaluates to either True or False) and a colon :.

  - If the condition is True, the indented code block immediately following the if statement is executed.

  - The else keyword (followed by a colon :) provides an alternative code block that is executed only if the preceding if condition (and any elif conditions) are False
"""

is_male = True
is_tall = False

if is_male: # Condition: Is 'is_male' True?
    print("You are a male")
else:       # This block executes if 'is_male' is False
    print("You are not a male")

"""
Combining Conditions"""

is_male = True
is_tall = True

if is_male and is_tall: # Both 'is_male' AND 'is_tall' must be True
    print("You are a tall male")
else:
    print("You are either not male or not tall or both")


is_male = False
is_tall = True

if is_male or is_tall: # Either 'is_male' OR 'is_tall' (or both) must be True
    print("You are a male or tall or both")
else:
    print("You are neither male nor tall")

"""Multiple Conditions:"""

is_male = True
is_tall = False

if is_male and is_tall:
    print("You are a tall male")
elif is_male and not is_tall: # Condition: if male AND NOT tall
    print("You are a short male")
elif not is_male and is_tall: # Condition: if NOT male AND tall
    print("You are not a male but are tall")
else: # This 'else' catches any other combination (neither male nor tall)
    print("You are not a male and not tall")

accuracy = float(input("Enter accuracy: "))

if accuracy > 0.95:
    print("Model performance is excellent! Ready for deployment.")
elif accuracy > 0.8:
    print("Model is good, but could be improved.")
else:
    print("Model needs more training.")



print("Model performance is excellent! Ready for deployment." if accuracy > 0.95 else "Model needs more training.")

"""####Loops (for)
A for loop is a versatile type of loop in Python used to iterate (loop) over the elements of a collection. This includes iterating through individual characters in a string, items in a list, or a sequence of numbers generated by the range() function
#####Syntax:
Python

    for variable in iterable:
        # code block to be executed for each item

- for: This is the keyword that initiates the for loop.
- variable: This is a temporary variable that takes on the value of each item in the iterable during each iteration.
- in: This keyword connects the variable to the iterable.
- iterable: This is the sequence or object that the loop will iterate over.

The indented block of code below the for statement is the body of the loop, which is executed for each item.
"""

for letter in "Amir Lab":
    print(letter)

"""Looping through a list"""

# Let's process our list of features
features = [1, -2, 3, 4.1, 0]

for f in features:
    print(f)


# CODE CELL
# len(features) is 5, so range(len(features)) becomes range(5), which generates indices 0, 1, 2, 3, 4
for index in range(len(my_friends)):
    print(my_friends[index]) # Accesses each friend using its gene

"""Basic for loop with range"""

#Basic for loop with range

for i in range(5):  #default i= 0 and increment 1
    print(i)

for i in range(3, 7):
    print(i)


#Loop with custom increment using range(start, stop, step)

for i in range(0, 10, 2):  # Even numbers from 0 to 8
    print("Even number:", i)

"""Enumerate Though a list"""

# Sometimes you need the index AND the value. Use enumerate()!
print("\nProcessing with index:")
for index, value in enumerate(features):
    print(f"Feature at index {index} has value {value}")

"""Iterate though a Dictionary"""

# Iterate through key-value pairs (items)
print("\nTraversing through items:")
for key, value in hyperparameters.items():
    print(f"Key: {key}, Value: {value}")

# Alternative way to iterate through keys (default)
print("\nTraversing through keys (default):")
for key in hyperparameters:
     print(f"Key: {key}, Value: {hyperparameters[key]}")

"""#####Control Flow Statements:
- break: Terminates the loop entirely.
- continue: Skips the current iteration and proceeds to the next one.
"""

for i in range(7):
    if i == 2:
        continue  # Skips 2
    if i == 6:
        break     # Exits at 4
    print(i)

"""### Functions: Reusable Blocks of Code
A function is a fundamental programming concept that allows you to define a collection of code that performs a specific, well-defined task. Functions are crucial for organizing your code by breaking it down into smaller, logical, and reusable chunks

####Defining a Function
 Functions are defined using the def keyword, followed by the function name, parentheses (which may contain parameters), and a colon. The function's code block is then indented.
"""

def greet(): # Defines a function named 'say_hi'
    print("Hello, user!") # This indented line is part of the function

"""####Calling a Function
Defining a function merely specifies what it does; it does not execute the code within it. To run the code inside a function, you must call (or invoke) the function by typing its name followed by parentheses ()
"""

def greet():
    print("Hello, user!")

print("Top of the program")
greet()
print("Bottom of the program")

"""####Function Parameters
Parameters are placeholders for pieces of information that you can pass into a function when you call it. They allow functions to be more flexible and perform their tasks differently based on the specific input provided
"""

def greet(name, age): # This function now accepts two parameters: 'name' and 'age'
    print(f"Hello {name}! You are  {age} ")
greet("Tamim", 40)
greet("Shakib", 32)

"""Default Argument"""

def greet(name, age=10): # This function now accepts two parameters: 'name' and 'age'
    print(f"Hello {name}! You are  {age} ")
greet("Tamim")

"""####Return Statement
The return statement is used within a function to send a value back to the point in the code where the function was called. This value is the result of the function's execution

-  A function will immediately exit upon encountering a return statement. Any code placed after return within that function will not be executed (it's "dead code").
- If a function doesn't have an explicit return statement, it implicitly returns None.
"""

def cube(num): # Function to calculate the cube of a number
    return num * num * num # Returns the calculated cubed value

# The value returned by 'cube(3)' is directly printed
print(cube(3))

# The value returned by 'cube(4)' is stored in a variable named 'result'
result = cube(4)
print(result)

"""###The Main Event: From Functions to Objects with class

A Python class serves as a blueprint or a template for creating objects. It encapsulates data (attributes) and functions (methods) that operate on that data into a single, cohesive unit. This approach aligns with the principles of Object-Oriented Programming (OOP), promoting code organization, reusability, and modularity.


####Key components of a Python class:
- "class" keyword:
Used to define a new class, followed by the class name (typically in CamelCase).
- Attributes:
   Variables that store data associated with an object. These can be:
  - Instance attributes: Unique to each object created from the class, defined within methods (often __init__) using self.attribute_name.
  - Class attributes: Shared by all instances of the class, defined at the class level outside any methods.
- Methods:
Functions defined within a class that perform actions on the object's data. Methods always take self as their first parameter, which refers to the instance of the class itself.
  - "__init__" method (Constructor):
A special method automatically called when a new object (instance) of the class is created. It is used to initialize the object's attributes.



"""

class Student:
    def __init__(self, name, major, gpa, is_on_probation):
            # 'self' refers to the current object being created
            # Parameters passed when creating an object (name, major, gpa, is_on_probation)
            # are assigned as attributes to the object using 'self.attribute_name'
            self.name = name
            self.major = major
            self.gpa = gpa
            self.is_on_probation = is_on_probation

    def on_honor_roll(self,limit=3.5):
        if self.gpa >= limit:
            return True
        else:
            return False

"""Create instances (objects): Call the class name like a function to create an object.



"""

student1 = Student("Jim", "Business", 3.8, False)
student2 = Student("Pam", "Art", 2.5, True)

"""Access attributes and call methods: Use dot notation to access an object's attributes and call its methods."""

print(student1.on_honor_roll(3.8))

"""1. Dataset Splitter (List Slicing)

Write a function named split_data(data, train_ratio=0.7) that:
Takes a list of data containing samples,

Returns a tuple (train_set, test_set) where train_set contains the first train_ratio proportion of the items and the remaining items are assigned to test_set.

"""

def split_data(data, train_ratio=0.7):
    if not 0 <= train_ratio <= 1:
        print("Error")
        #raise ValueError("train_ratio is not  between 0 and 1.")
    train_size = int(len(data) * train_ratio)
    train_set = data[:train_size]
    test_set = data[train_size:]
    return (train_set, test_set)



samples = ['sample1', 'sample2', 'sample3', 'sample4', 'sample5', 'sample6', 'sample7']
train, test = split_data(samples)
print("Training Set:", train)
print("Testing Set:", test)

"""2. Model Accuracy Statistics
Given a list of model accuracy scores from five experiments: [0.78, 0.85, 0.92, 0.76, 0.88]


Write a Python script to:
- Calculate and print the mean accuracy,

- Identify and print the highest accuracy,

- Compute the difference between the highest and lowest values,

- Display the rounded mean (up to two decimal places).


"""

accuracies = [0.78, 0.85, 0.92, 0.76, 0.88]

mean_accuracy = sum(accuracies) / len(accuracies)


highest = max(accuracies)
lowest = min(accuracies)
difference = highest - lowest

# Display results
print("Mean Accuracy:", mean_accuracy)
print("Highest Accuracy:", highest)
print("Difference Between Highest and Lowest:", difference)
print("Rounded Mean Accuracy (2 decimal places):", round(mean_accuracy, 2))

"""3. Confidence Score Classification

Simulate a classification task by generating 10 random float numbers between 0 and 1 representing confidence scores of a model.

 Then:

For each score, assign a predicted class based on the following rule:

Score ≥ 0.5 → Class 1

Score < 0.5 → Class 0

Print both the confidence scores and their corresponding predicted classes.

"""

import random
import numpy as np
confidence_scores = [0.78, 0.32, 0.56, 0.49, 0.91, 0.15, 0.67, 0.43, 0.88, 0.21]

confidence_scores = [random.uniform(0, 1) for _ in range(10)]
# confidence_scores = np.random.rand(10)
predicted_classes = []
for score in confidence_scores:
    if score >= 0.5:
        predicted_classes.append(1)  # Class 1 if score is 0.5 or more
    else:
        predicted_classes.append(0)  # Class 0 otherwise

#Show the result
print("Confidence Scores:", confidence_scores)
print("Predicted Classes:", predicted_classes)

"""4. Data Normalization Utility

Create a script that:

- Asks the user to input five numerical values (e.g., representing sensor readings),

- Identifies the maximum value,

- Normalizes each input by dividing it by the maximum value,

- Prints the resulting list of normalized values.

"""

values = []
for i in range(5):
    try:
        val = float(input(f"Enter value {i+1}: "))
        values.append(val)
    except ValueError:
        print("Invalid input. Please enter a valid number.")
        # raise ValueError
        # continue


max_value = max(values)

normalized_values = []
for v in values:
    normalized_values.append(v / max_value)

#Print the normalized values
print("Normalized Values:", normalized_values)

"""5. Model Recommendation System (Conditional Logic)

Write a function named recommend_model(data_size) that recommends a model type based on the size of the dataset:

- If data_size < 10,000, recommend "Logistic Regression",
- If 10,000 ≤ data_size < 100,000, recommend "Random Forest",
- Otherwise, recommend "Deep Learning".

Test the function with the values: 5,000, 50,000, and 500,000.
"""

def recommend_model(data_size):
    if data_size < 10000:
        return "Logistic Regression"
    elif data_size < 100000:
        return "Random Forest"
    else:
        return "Deep Learning"

# Test cases
print("For 5,000 samples:", recommend_model(5000))
print("For 50,000 samples:", recommend_model(50000))
print("For 500,000 samples:", recommend_model(500000))

"""6. Model Metrics Dictionary (Dictionary Operations)

Given two lists:

metrics = ["accuracy", "precision", "recall"]  

values = [0.85, 0.78, 0.82]

Perform the following:

- Create a dictionary mapping each metric to its corresponding value within an empty dictionary by traversing the list,
- Calculate the F1 score using the formula from the dictionary values:
 F1 = 2 × (precision × recall) / (precision + recall)
 and add it to the dictionary with the key "f1_score",
- Return a new dictionary that contains only those metrics whose value is greater than 0.80.

"""

metrics = ["accuracy", "precision", "recall"]
values = [0.85, 0.78, 0.82]


metric_dict = {} #empty Dict
for i in range(len(metrics)):
    metric_dict[metrics[i]] = values[i]


precision = metric_dict["precision"]
recall = metric_dict["recall"]
f1_score = 2 * (precision * recall) / (precision + recall)
metric_dict["f1_score"] = f1_score


filtered_metrics = {}
for key, value in metric_dict.items():
    if value > 0.80:
        filtered_metrics[key] = value

# Final result
print("Filtered metrics (value > 0.80):")
print(filtered_metrics)

"""7. Activation Function Calculator (Mathematical Functions)

Define a function activation(x, func='relu') that implements:

- ReLU: max(0, x)
- Sigmoid: 1 / (1 + exp(-x))
- Tanh: Use Python's math.tanh(x)

To access exp() and tanh() use python math libery using the code

      Import math

Then access

      math.exp() or math.tanh()

 Test with:
 activation(2.5), activation(-1, 'sigmoid'), and activation(0, 'tanh').

"""

import math

def activation(x, func='relu'):
    if func == 'relu':
        return max(0, x)
    elif func == 'sigmoid':
        return 1 / (1 + math.exp(-x))
    elif func == 'tanh':
        return math.tanh(x)
    else:
        return "Invalid activation function"

# Test the function
print("ReLU on 2.5:", activation(2.5))
print("Sigmoid on -1:", activation(-1, 'sigmoid'))
print("Tanh on 0:", activation(, 'tanh'))

"""8. Image Preprocessing Function (List Operations)

Define a function preprocess_image(pixels) that:

Accepts a list of integers pixels in the range [0, 255],


- Normalizes the list to a [0, 1] range using the formula:

      Norm(xᵢ) = (xᵢ - min(X)) / (max(X) - min(X)),


- Sets any normalized value less than 0.1 to 0,


- Returns the processed list.



"""

def preprocess_image(pixels):
    # Handle empty list edge case
    if not pixels:
        return []

    min_val = min(pixels)
    max_val = max(pixels)

    # Avoid division by zero (if all pixels are identical)
    if max_val == min_val:
        normalized = [0.0] * len(pixels)
        return normalized



    # processed = []
    # for x in pixels:
    #     # Normalize each pixel
    #     normalized = (x - min_val) / (max_val - min_val)
    #       if normalized < 0.1:
    #         normalized = 0.0
    #     processed.append(normalized)


    # type 2:
    normalized = [(x - min_val) / (max_val - min_val) for x in pixels] #this code represent pythonic leap : instead writinh the entire commented code below
    processed = [0 if x < 0.1 else x for x in normalized] #if pythonic leap not used then the for loop will be in processed list

    return processed

simple_pixels = [30, 90, 5, 200]
print(preprocess_image(simple_pixels))

"""9. Object-Oriented Bank Account System (OOP Fundamentals)

Design a class BankAccount that includes the following methods:

- deposit(amount) to add funds,


= withdraw(amount) to deduct funds,


- display_balance() to print the current balance.

Demonstrate the functionality by creating an object of the class and invoking each method interactively.

"""

class BankAccount:

    def __init__(self, initial_balance=0):
        """Initialize with optional starting balance (default 0)"""
        self.balance = initial_balance


    def deposit(self, amount):

        if amount > 0:
            self.balance += amount
            print(f"Deposited ${amount:.2f}")
        else:
            print("Deposit amount must be positive!")


    def withdraw(self, amount):

        if amount > self.balance:
            print("Insufficient funds!")
        elif amount > 0:
            self.balance -= amount
            print(f"Withdrew ${amount:.2f}")
        else:
            print("Withdrawal amount must be positive!")


    def display_balance(self):

        print(f"Current Balance: ${self.balance:.2f}")




my_account = BankAccount(100)  # Starts with balance $100

# Test operations
my_account.display_balance()
my_account.deposit(50)
my_account.withdraw(30)
my_account.withdraw(200)
my_account.display_balance()

"""10. AI Model Performance Tracker (Object-Oriented Programming Basics)

Design and implement a Python class named AIModel to simulate the performance tracking of an AI model during the training phase. This exercise introduces basic principles of object-oriented programming (OOP), including class construction, attribute manipulation, and method implementation.

    Class Specification:
        Class Name : AIModel
    Attributes:
        model_name (str): A string representing the name of the AI model (e.g., "Cat Detector").
        accuracy (float): The current performance score of the model, represented as a float between 0.0 and 1.0.
        epochs_trained (int): The total number of training epochs completed.
    Methods:
        train(epochs, accuracy_boost)
            - Simulates model training by incrementing the epochs_trained by the specified number of epochs.
            - The accuracy should be increased by 0.1 x (1 - Current Accuracy).
            - Ensure that the accuracy does not exceed the upper bound of 1.0.
        evaluate()
            - Returns a descriptive string summarizing the training status in the following format:
            - "Cat Detector: 50 epochs trained, Accuracy=0.85"
        is_ready_for_deployment()
            - Returns a Boolean value:
                    True if the model’s accuracy is greater than or equal to 0.90.
                    False otherwise.

"""

class AIModel:

    def __init__(self, model_name, initial_accuracy=0.0):
        """
        Initialize the model
        :param model_name: str (e.g., "Cat Detector")
        :param initial_accuracy: float between 0.0-1.0
        """

        self.model_name = model_name
        self.accuracy = min(max(initial_accuracy, 0.0), 1.0)  # Ensures 0.0 ≤ accuracy ≤ 1.0
        self.epochs_trained = 0

    def train(self, epochs):

        for _ in range(epochs):
            self.accuracy += 0.1 * (1 - self.accuracy)
            self.epochs_trained += 1

        # Ensure accuracy never exceeds 1.0
        self.accuracy = min(self.accuracy, 1.0)

    def evaluate(self):

        return f"{self.model_name}: {self.epochs_trained} epochs trained, Accuracy={self.accuracy:.2f}"

    def is_ready_for_deployment(self):

        return self.accuracy >= 0.90




# Create a model
cat_detector = AIModel("Cat Detector", 0.6)

cat_detector.train(10)

print(cat_detector.evaluate())

print("Ready for deployment?", cat_detector.is_ready_for_deployment())


# Train more until ready
cat_detector.train(5)
print(cat_detector.evaluate())

print("Ready now?", cat_detector.is_ready_for_deployment())

a

